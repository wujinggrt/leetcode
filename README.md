
Loop invariant，定义满足的条件，根据满足的条件，可以保证和获取信息结论: 
- 初始状态，满足条件。定义满足的条件，对解决问题十分重要。比如二分查找，满足左侧都是小于 key，右侧都是大于等于 key。最终，收缩到 `[left, right)` 且 left==right，又 left 是第一个大于等于 key 的值。
- 循环迭代：
    - 循环步骤开始前，满足状态。
    - 循环步骤执行时，代码执行，修改了状态。可能改变区间大小，维护的状态。
    - 循环步骤末尾，更新区间下标，更新状态，保证循环步骤执行完，进入下一轮循环后跳出循环后，依然满足条件。
- 循环结束，满足条件。


## 不会的内容

- 44

## Tips:

**展开短函数**：对于经常调用的部分，如果写成短函数，可能函数的压栈和弹栈会拉慢速度，所以速度敏感部分应该适当避免此情况，用可读性换速度。

**加速查询（空间换时间）**：使用 map 和数组来加速查询和变换。比如 Python 的 str() 和 int() 函数，转换明显慢于查表，特别当位数确定时，值域确定时，使用查表会更快。

**Python 求模与 C++ 不同**：Python 中，负数取模与正数不同，取模结果为正数，结果为对应的模的数的补数。比如 -17 % 10 得到 3，如果想要 7，应当用 10 减去负数取模结果。在负整数的整数除法中，会向下取整，比如 -17 // 10 得到 -2，而不是 -1，可以看到整数除法都是向下取整。如果想要达到与 C++ 相同效果，那么负数的整数除法和取模应当调整如下：

```py
digit = 0 if x % 10 == 0 else x % 10 - 10
n = (n - digit) // 10
```

## TODO
- [ ] 1
- [ ] 2
- [ ] 3
- [ ] 4
- [ ] 5
- [ ] 6
- [ ] 7

- [ ] 8
- [ ] 10 字符串匹配

```py
  # dp，状态：f[i][j] 表示 s 前 i 字符与 p 前 j 字符匹配
  # 转移方程如下，根据 p[j]：
  # matches(x, y) 判断两字符是否匹配，或者 y 是 .
  # p[j] 为 *，f[i][j] = f[i-1][j] or f[i][j-2] if matches(s[i], p[j-1]) else f[i][j-2]
  # p[j] 为 小写字符或 ., f[i][j] = f[i-1][j-1] if matches(s[i], p[j]) else False
  # 解释：
  # 1. 当 p[j] 为 *, 第 j-1 个字符匹配 0 次，即不匹配情况下，把 p 的匹配在 j-1 j 处当 0 次匹配。
  #    于是，f[i][j] = f[i][j-2]
  # 2. 匹配 1,2,3... 次情况下，有 f[i][j] = f[i-1][j-2] if s[i]==p[j-1]
  #    f[i][j] = f[i-2][j-2] if s[i-1]==s[i]==p[j-1], ...
  #    如此编程比较麻烦，所以把匹配 1,2,3... 次当做 + 的语义考虑，本质为两种情况：
  #    p[j] 相当于 +，s[i] 与 p[j-1] 匹配之后，
  #    1) 考察 s[i-1] 是否继续进行匹配 p[0..j], 消去了最后一个s[i]影响，此时为 True，
  #       考察前面情况，对应 f[i-1][j], 如此递归地直到 + 只匹配一个的情况。
  #    2) 如果不能匹配，放弃匹配，当做 + 只匹配到 1 个字符的情况，此时为 True，于是参考前面是否匹配，
  #       即可对应 f[i][j-2]，把 p 中 j-1 和 j 字符当做
  #       0 次匹配处理
  #    f[i][j] = (f[i-1][j] or f[i][j-2]) if s[i]==p[j-1] else f[i][j-2]
```

- [ ] 11

复杂的双指针。

- [ ] 12
- [ ] 14
- [ ] 15
- [ ] 16
- [ ] 17
- [ ] 19
- [ ] 20
- [ ] 22

关注 dfs 和 backtrack.

- [ ] 23
- [ ] 24
- [ ] 25

## 31 next permutation
思路偏记忆。具体如如：12465的下一个应该是123564
1.应该从右向左找数组A，下标为i；
2.在第一个A[i-1] > A[i]的数，然后在和左边第一个比i小的数交换，这样才能得到下一个比当前大的数。
3.将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，因为升序排列就是最小的排列，也就是那一部分的站在高位的数尽可能小。

## 32 最长有效括号：DP 和哨兵思路

Tag：栈 (最优)，DP

最佳思路为使用栈。遍历时可以根据过往来判断当前是否有效。记录有效匹配括号数量即可。

巧妙设计和见解：开始前令栈底预先保存一个 '(' 下标 -1，作为哨兵。用于检查遇到的第一个不匹配的 ')'，及时处理和重新清零计数。设置新的哨兵，检查下一个不匹配的 ')'。

这是非常值得学习的思路。使用**哨兵思路**或占位，一般多设计一个匹配对应目标的对象，方便检测。哨兵可以方便地检查第一个出现不匹配，或者推广来说，检查第一个出现异常的地方。妥当处理。

遍历到 '(' 时，将下标入栈。遍历到 ')' 时，直接弹栈。弹栈后，
- 如果栈非空，那么栈顶的元素下标是未匹配的左括号，记为 v。即当前括号 ')' 下标为 m。于是有区间 (v, m] 匹配到括号。当前有效括号数量是 m - v 个。
- 如果栈空，说明弹出了哨兵，代表当前有括号不匹配。于是把当前下标作为哨兵，再次入栈。

洞察栈的**规律**。用不同方法表达，可以优化空间复杂度到 O(1)。不使用栈，使用两个计数器即可。栈中总是保存 "("，内容是 "((((...("，有**冗余**，有规律和优化空间。每当匹配到 ")" 时逐个弹出。当 ")" 数量过多，匹配不到 "("，便认为无效。

最后的方案：使用两个变量模拟如此关系的栈。需要从左往右扫描，也需要从右往左扫描。
- 从左往右扫描时，以 left 必须大于等于 right。否则右侧括号，找不到左括号来匹配。 但是，从左往右扫描，会漏掉一种情况。比如 "()(()" 总是满足 left >= right，但长度是 2 所以需要从右扫描一遍。
- 从右向左扫描。一左一右，将两个情况左右限制在最大值上。

## 33 搜索旋转排序数组：二分查找状态机

数组有序，但是可能向左或向右 rotate 了。比如 [4 5 6 7 0 1 2]。

使用二分查找。二分后，得到 mid，需要确定，值是在 mid 的左侧还是右侧。考虑**状态机**。我们定义跨越点下标 leap 是最小值点，且此最小值左最大值。如果不存在如此的值，那么数组单调增加。如果 nums[0] < nums[-1]，代表使用二分查找即可。或是用哨兵思想，在左侧插入无穷大，但是复杂化了。二分区间 [left:right] 时，下标 mid 有如下情况：
- 情况 1：nums[left] > nums[mid]。左侧区间不单调。跨越点在 mid 左侧区间 [left, mid)，数组单调递增序列包含 [left:leap] 和 [leap:mid] [mid:right]。
- 情况 2：nums[left] < nums[mid] and nums[right-1] < nums[mid]，跨越点在 mid 右侧区间 [mid:right]。单调递增区间包含 [left:mid], [mid:leap] 和 [leap:right]。
- 情况 3：nums[left] < nums[mid] and nums[mid] < nums[right-1]，区间有序，无跨越点。执行二分即可。

有了上面信息，便逐渐收缩 left 和 right，锁定 target 所在区间。当发现有三个递增区间时，不能像二分直接找下一个区间，放宽条件，到可能存在数的区间即可。由于 leap 下标未知，为了简洁，判断 target 是否在已知的单个单调的区间更方便。

[python code](./py/0033.py)

## 34 搜索有重复元素的有序数组：二分查找，lower_bound upper_bound

lower_bound，找到第一个不小于 target 的元素。upper_bound，找到第一个大于 target 的元素。

[py code](./py/0034.py)

## 39 Combination sum：DFS 和状态转移，讨论 Dfs 两种形式

给出不同数字，组合出和为 target 的组合。首先，考虑 DFS。**在 DFS 中，重点关注每轮需要什么状态，更新什么状态，判断什么情况终止**。每轮需要当前下标 i 和 target，代表以 i 出发，找到和为 target 的组合。随着搜索深入，不断更新下标和 target。target 为 0 即已经找到，便记录此路径。终止条件是 i 到了列表边界；或值已经超过 target，深入下去只会更大，必然不可能有解；或组合已经找到，再遍历下去只会更多。

DFS 一般有两种形式，在函数首尾 append 和 pop。这种形式，第一次调用时不用预先加入第一个节点，直接代表以 i 为起点，找到和等于 target 的组合。CLRS 的伪代码是此形式。

```py
    def _dfs(self, i: int, target: int):
        """
        以 i 为起点，找到和为 target 的组合。先判断是否满足条件，或是否不能搜索，即使 prune
        """
        if target == 0:
            self._combinations.append(deepcopy(self._track))
            return
        self._track.append(self._candidates[i])
        next_target = target - self._candidates[i]
        for j, num in enumerate(self._candidates[i:], start=i):
            if target < num: # 不可能存在，当前 num 也不满足
                break
            self._dfs(j, next_target)
        self._track.pop()
```

注意，在调用 dfs 时，都需要遍历所有情况的 root，即：

```py
for i in veticies:
    dfs(i, ...)
```

或在循环内 append 和 pop。这种形式需要先追加第一个 root 元素。看起来更简洁。

```py
class Solution:
    def _dfs2(self, i: int, target: int):
        """
        以 i 为起点，找到和为 target 的组合。先判断是否满足条件，或是否不能搜索，即使 prune
        """
        if target == 0:
            self._combinations.append(deepcopy(self._track))
            return
        # for j, num in enumerate(self._candidates[i:], start=i):
        for j in range(i, len(self._candidates)):
            num = self._candidates[j]
            if num > target:
                break # 不可能存在
            self._track.append(num)
            self._dfs2(j, target - num)
            self._track.pop()

    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        self._candidates = candidates
        self._track = list()
        self._combinations = list()
        self._candidates.sort()
        self._dfs2(0, target)
        return self._combinations
```

但是本题可以多次使用一个元素，所以需要对 DFS 中寻找下一轮数做出调整。只需要再从当前 i 出发搜索，可以当做寻找重复的元素。即：

```py
        self._track.append(self._candidates[i])
        for j in range(i, len(self._candidates)):
            self._dfs(j, target - self._candidates[i])
        self._track.pop()
```

可以根据情况，选择两种形式。

假设，如果此题去掉不包含重复元素的限制，那么需要考虑**排除 DFS 重复项**：比如，[2 2 2 2] 中找到 target 为 4 的组合，自然是 [2 2]。简单的 DFS 会找到多组 [2 2]。所以，第一轮之后，要跳过重复元素。比如，i=0，已经选择了 nums[i] 和 nums[i+1]，如此 DFS 下去，便只会找到更多重复的。所以在第一轮 (nums[0], nums[1], ...) 序列搜索完成后，nums[1] 不能与 nums[0] 相等，否则重复序列了。所以需要找到两个不相等的序列。记录一下 previous 即可。具体参考 3 Sum 一题。

## 40 Combination Sum II：包含重复数字，DFS

不能重复使用同一个下标元素了，因为包含了重复数字。

```py
    def dfs(self, i: int, target: int):
        if target == 0:
            self.combinations.append(deepcopy(self.track))
            return
        previous = -1
        for j, num in enumerate(self.candidates[i+1:], start=i+1):
            if num > target:
                break
            if previous != -1 and num == self.candidates[previous]:
                continue # duplicated
            previous = j
            self.track.append(num)
            self.dfs(j, target - num)
            self.track.pop()
```

调用时，从传入 i=-1, target=target 即可遍历所有。

注意 dfs()，使用了 previous 变量，保障在重复元素相邻（有序）时，起点相同的数只会出现一次，避免重复。加入不做此处理，比如：[1 1 2 5 6] target=8，其中，第一轮 i=0，选择 1，此轮的 dfs 继续，选择了 i=2 和 i=4，[1 2 5]。dfs 回溯到此轮，i=1 时继续搜索，还会得到 [1 2 5]。相邻重复元素作为起始 [1 1 ...]，后面部分是相同的，尽管 1 来自不同下标（0 和 1），但是结果是重复的。

## 41 缺失正数

在未排序数组，找到第一个缺失正整数，要求时间复杂度 O(n)，空间复杂度 O(1)。不能够选择排序和哈希的策略。所以只能折中，原地修改数组，实现类似哈希表的功能。长度为 n 的数组，缺失正数在 [1,n+1]。遍历数组，如果当前数为 x，那么就在 arr[x-1] 处打上标记（下标要减 1 作为 offset）。如果最后，所有元素都打上标记，那么结果就是 n+1，否则就是第一个未打标记的数。

如果数组都包含了 [1,n]，答案是 n+1，否则答案在 [1,n] 内。原地哈希思路将范围 [1,n] 的数放入哈希表。我们把原数组对应位置的 arr[x-1] 取负号作为标记，代表 x 出现过，并且可以通过取绝对值获取原 arr[x-1] 处的结果，不丢失信息。如此，一个数组的元素有了两层含义：正负代表此下标 +1 的数是否出现，绝对值代表原来保存的内容。为了避免原数组出现小于等于 0 的数带来干扰，设置为 n+1。执行思路如下：
- 遍历数组，将 <= 0 的数都设置为 n+1，避免干扰。
- 遍历数组每个元素 x，如果 0 < x <= n，arr[x-1] = -abs(arr[x-1])，作为标记。
- 处理结束后，开始遍历扫查缺失项，即第一个非负数字下标 +1 的数即需要的。

## 42 接雨水：单调栈和 DP

### 单调栈：站内元素单调递减

两条 bar 围住的水面高度取决于较短者。当前下标 bar，能够围住水面高度，取决于后者第一个比它高的 bar，所以使用单调栈，来确定当前下标 bar 的右边界。

如果发现不满足单调栈的性质，当前元素比栈顶要大。那么开始计算积水的量。注意，积水数量是逐层计算的，而非一次计算完全。

在单调栈的性质中，每次遇到不满足单调性质的情况时，不断弹栈，以弹栈的元素作为水底，弹栈后剩余的栈顶作为水面，逐层求得积水。一般，逐层只会处理三个元素，左右 bar 和栈底。

### DP

状态保存：left_max: list[int]，left_max[i] 记录下标 i 处左侧 (包含当前的 i，这样最高处为当前 i 时，高差即 0，积水量自然为 0，满足要求) 最高的 bar。right_max: list[int] 同理。正向遍历数组，可以计算 left_max，反向遍历可以更新 right_max。

注意，积水被分隔为多段时，说明存在一个较高的峰，左右都是较低的 bar，类似数学里的极大值。

遍历时，通过左右最高的 bar，计算水面高度。再根据当前 height[i] 可以计算凹陷高度。高差即当前 i 处积水量。

优化空间：实际上，left_max 中，较大的值，只用了一次。每次遍历到 i 时，只会参考 left_max[i]。并且，下一次，只会用 max(left_max[i], height[i+1]) 更新到 left_max[i+1]。并且 left_max[0:i+1] 不会再次访问。可以看到，更新下一个状态，只会用到当前状态。于是，只需要一个变量 left_max_height 表示状态。右侧类似，更新 right_max 只需要当前状态，所以也只需要一个变量 right_max_height 表示状态即可。

接下来，把更新左右两侧最高 bar 融入遍历 height 的过程。那么，何时更新存储的水？由于计算左右最高点时，需要从左右两侧分别考虑，所以使用双指针 i 和 j，分别指向左右边界，不断逼近并更新。

每次更新，需要左右，即下标 i 或 j 处的水平面，以宽度 1 为单位，计算较低者的水面（left_max_heigt 与 i 较小者为左侧水面，或 right_max_height 与 j 较小者为右侧水面）及其深度，接着计数并更新。选择 height[i] 和 height[j] 较小一侧计算水面，保证左右连通时，选择较低的水面。进一步迭代。最后，i==j 时，代表所有水面已经计算过了。

Loop invariant:
- 开始前，左右两侧水面满足高度是较小者。
- 计算较小侧接水数量。

## 43 字符串相乘

首先确定数字有多少位，再确定相乘后的结果有多少位，初始化如此位数的 0，把每个相乘的结果逐渐相加。

记 num1 和 num2 分别长度为 n, m，结果 res 长度可能是 n+m 或 n+m-1。比如，num1 = 123， num2 = 456，从左往右地处理，把 num1 看做 [100, 20, 3] 来处理，便可把 num2 分别扩大 100 倍乘以 1，扩大 10 倍乘以 2 来加到结果上。

计算时，首先确定当前数字应当添加到结果的哪一位。分别考察操作的数字字符所在 num1 和 num2 位置，再计算目标位置即可。

## 44 通配符匹配：DP

注意，不是正则：
- ?: 匹配任何单个字符
- *: 匹配任何序列

首先抽象和定义问题，需要定义状态和状态转移公式。

状态：dp[i][j] 表示 s 前 i 个字符和 p 前 j 个字符是否匹配。

状态转移，根据 p[j] 判断如下：
1. 小写字母：dp[i][j] = s[i-1] == p[j-1] and dp[i-1][j-1]。比较当前字符。
2. *：dp[i][j] = dp[i][j-1] or dp[i-1][j]。
    - dp[i][j-1] 为 True 代表 p[:j-1] 能够匹配 s[:i]。此时，* 匹配空，不展开。
    - dp[i-1][j] 为 True 代表 s[:i-2] 匹配 p[:j]。p[j-1] 字符 * 还可以继续匹配 s[i-1]。* 匹配任意字符的展开，从匹配 0 个字符开始，不断在此分支继续匹配新的 s[i-1], s[i], s[i+1], ...。可以看到，* 匹配任意字符，s 在 i-1 下标处，直到末尾，都可以被 * 匹配。于是，可以剪枝，从 i-2 开始到末尾直接设置 dp[i:][j] = True。
3. ?: dp[i][j] = dp[i-1][j-1]。? 匹配任何符号，相当于 s[i-1] == p[j-1] 总是为 True。

初始状态，所有为 False，除了以下部分：
- dp[0][0] = True
- dp[0][:k] = True, p[:k-1] 全为 True

## 44 跳跃游戏：贪心

使用动态规划，记录站在本格子 i 上能到达的最远位置 p[i] = max(p[i-1], i + nums[i])。顺序查找最小的能跳到最后位置的位置，然后不断递推，直到找到最开始的位置并记录次数。

跳到每个位置后，确定下一步跳跃的区间 [i:nums[i]+i+1]。在区间内，找到能够跳到最远位置的点，而非最大值的点。选择能跳到最远的作为下一跳。下一跳位置和最远位置确定了新的区间，再重新找能跳到最远位置的点，直到确定边界到达或超过末尾。

假设：某个区间，是否存在一个不跳到 max_position 的位置，经过它能更小的步数跳到末尾？可以验证。

$i$ 为当前位置，区间为 $\mathbb{R}_i=[i, i+nums[i])$，假设经过位置 $m \in \mathbb{R}_i$，能够到达最远处 $m + nums[m]$，有如下情况：
- 假设 $m + nums[m]$ 到达或超过数组边界，只需一步跳到 m，再跳一步便完成
- 假设 $m + nums[m]$ 仍在数组内：
    - ​​后续跳跃次数的优化性​​：假设存在一个位置 l，其后续跳跃次数比贪心选择的 max_position 更少。根据贪心策略的定义，贪心选择的 max_position 是当前区间内所有位置能跳到的最远点，这意味着从该点出发的后续覆盖范围一定比从 l 出发的更广。
    - ​​反证法​​：若存在更优的非贪心选择，则说明该选择点 l 的后续**覆盖范围**更小，需要更多次跳跃才能到达终点，这与假设矛盾。因此贪心策略的每一步选择均保证了全局最优。

## 46 排列组合：Dfs + 去重

使用一个 list，当做 visited 的记录。

## 47 排列组合（去重）: Dfs + 去重，相邻重复元素仅处理一次

如果满足如下条件，应当跳过：

```py
visited[i] or (i != 0 and nums[i] == nums[i - 1] and not visited[i - 1])
```

上述表达式真时，说明相邻重复元素中，已经以第二个重复的数字为出发点开始递归。最终得到重复结果，需要剪枝。


## 48 Rotate Image: 矩阵旋转 90 度

相当于先转置，后调换列的位置。

## 49 Group Anagrams

题意：把具有相同字符的单词组合在一起。思路一：把每个字符串用新的 char 数组排序后，拼接位字符后，用哈希表查找。时空复杂度较高。思路二：使用计数的思路。

## 50 Pow: 分支

求 n 次方时，可以把 n 看做是二进制的。比如 5=0b101，那么 $3^5=3^1 * 3^4 = 3^{1 * 0b1} * 3^{0 * 0b10} * 3^{1 * 0b100}$，可以沿着幂，不断收录相乘的项，累乘到结果中。

- [ ] 51
- [ ] 53
- [ ] 54
- [ ] 55
- [ ] 56
- [ ] 57
- [ ] 59
- [ ] 60
- [ ] 61
- [ ] 62
- [ ] 63
- [ ] 64
- [ ] 70
- [ ] 72
- [ ] 74
- [ ] 75
- [ ] 76
- [ ] 78
- [ ] 79
- [ ] 81
- [ ] 82
- [ ] 84
- [ ] 85
- [ ] 86

## 88 合并两有序数组：双指针+尾插

第一个数组尾部有空闲位置，使用双指针，从后向前遍历，取较大者插入空闲位置，时间复杂度为 O(1)。如果使用前插法，会设计插入位置后续数字偏移一个单位，复杂度为 O(n)。

- [ ] 91
- [ ] 92
- [ ] 93
- [ ] 95
- [ ] 96
- [ ] 97
- [ ] 98
- [ ] 99
- [ ] 101
- [ ] 102
- [ ] 103
- [ ] 104
- [ ] 105
- [ ] 106
- [ ] 110
- [ ] 111
- [ ] 112
- [ ] 113
- [ ] 114
- [ ] 115
- [ ] 120
- [ ] 121
- [ ] 122
- [ ] 123
- [ ] 124
- [ ] 127
- [ ] 128
- [ ] 129
- [ ] 130
- [ ] 131
- [ ] 132
- [ ] 135
- [ ] 136
- [ ] 138
- [ ] 139
- [ ] 140
- [ ] 142
- [ ] 143
- [ ] 144
- [ ] 145
- [ ] 146
- [ ] 148
- [ ] 152
- [ ] 154
- [ ] 155
- [ ] 160
- [ ] 162
- [ ] 164
- [ ] 165
- [ ] 169
- [ ] 174
- [ ] 179
- [ ] 188
- [ ] 198
- [ ] 199
- [ ] 200
- [ ] 206
- [ ] 207
- [ ] 208
- [ ] 209
- [ ] 211
- [ ] 212
- [ ] 213
- [ ] 215
- [ ] 221
- [ ] 222
- [ ] 224
- [ ] 226
- [ ] 227
- [ ] 230
- [ ] 233
- [ ] 234
- [x] 236 lowestCommonAncestor
- [x] 239 maxSlidingWindow

使用双端队列，队列内容保存数组的下标，对应的元素满足单调递减的关系，队首对应当前窗口的最大值。每次添加元素只能从尾部添加， 有违反顺序的元素的时候，pop所有比当前元素小的元素。 我们需要的只是最大值，所以不会对结果影响。
- [x] 240 searchMatrix # 使用二分查找不合适，用二叉树的思路。此题不够熟悉

将矩阵逆时针旋转45度，可以得到类似二叉树的结构。我们记矩阵中，右上角的元素为root。我们从根开始处理，根的下标为(i,j)=(0,n-1)，其中左分支元素变小，对应下标j--，右分支元素变大，对应下表i++。当：
  1. root > target ，则 target 一定在 root 所在矩阵的列的左侧，执行--j。
  2. root < target ，则 target 一定在 root 所在矩阵的列的右方，即 root 所在列可被消去，执行++i。
  3. root==target，返回true。若最后无结果，返回false。

insights在于：简单的在各行或列二分搜索，会各自遗漏列和行的顺序，。我们可以进一步观察规律，横纵行不通，考虑逆时针旋转45度后，按照二叉树的方式处理。
- [x] 242 isAnagram
简单的使用数组替代哈希，统计出现次数后再比较。
- [x] 264

转移方程：dp[i]=min(dp[p_2]*2,dp[p_3]*3,dp[p_5]*5)。p2,p3,p5分别是丑数序列的下标，用于递推丑数序列。由于丑数需要满足递增，所以 更新序列时候，从p2,p3,p5指向的丑数中，分别乘以2，3，5，选取最小值作为更新， 并将对应的下标自增，移动到下一个下标。
- [ ] 275
- [ ] 279
- [ ] 287
- [ ] 295
- [ ] 297
- [ ] 300
- [ ] 309
- [ ] 312
- [ ] 313
- [ ] 315
- [ ] 316
- [ ] 321
- [ ] 322
- [ ] 327
- [ ] 328
- [ ] 329
- [ ] 336
- [ ] 337
- [ ] 343
- [ ] 347
- [ ] 349
- [ ] 354
- [ ] 357
- [ ] 363
- [ ] 377
- [ ] 381
- [ ] 382
- [ ] 384
- [ ] 394
- [ ] 398
- [ ] 402
- [ ] 403
- [ ] 406
- [ ] 407
- [ ] 410
- [ ] 416
- [ ] 438
- [ ] 440
- [ ] 443
- [ ] 445
- [ ] 450
- [ ] 452
- [ ] 454
- [ ] 458
- [ ] 463
- [ ] 468
- [ ] 470
- [ ] 473
- [ ] 474
- [ ] 480
- [ ] 486
- [ ] 494
- [ ] 498
- [ ] 504
- [ ] 509
- [ ] 514
- [ ] 516
- [ ] 518
- [ ] 523
- [ ] 538
- [ ] 543
- [ ] 560
- [ ] 567
- [ ] 583
- [ ] 647
- [ ] 654
- [ ] 662
- [ ] 673
- [ ] 677
- [ ] 678
- [ ] 679
- [ ] 692
- [ ] 695
- [ ] 698
- [ ] 704
- [ ] 714
- [ ] 718
- [ ] 739
- [ ] 752
- [ ] 761
- [ ] 845
- [ ] 862
- [ ] 871
- [ ] 879
- [ ] 887
- [ ] 895
- [ ] 912
- [ ] 922
- [ ] 941
- [ ] 958
- [ ] 973
- [ ] 1044
- [ ] 1095
- [ ] 1114
- [ ] 1122
- [ ] 1143
- [ ] 1160
- [ ] 1206
- [ ] 1207
- [ ] 1312
- [ ] 1339
- [ ] 1356
- [ ] 1365
- [ ] 1373
- [ ] 1379
- [ ] 1382
- [ ] 1420
- [ ] 1423
- [ ] 1449
- [ ] 1877
- [ ] 1996
- [ ] 2058
- [ ] 3156
- [ ] 3613
- [ ] 4387